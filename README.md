

### Common Data Structures 🏗️

1. **Arrays** 📊
   - A collection of elements identified by index or key, allowing for fast access and manipulation.

2. **Linked Lists** 🔗
   - A sequence of elements where each element points to the next, enabling efficient insertion and deletion.
   - **Singly Linked List** ➡️: Each node points to the next node, forming a unidirectional chain.
   - **Doubly Linked List** ↔️: Each node points to both the next and previous nodes, allowing traversal in both directions.

3. **Stacks** 📚
   - A collection of elements that follows the Last In First Out (LIFO) principle, where the last added element is the first to be removed.

4. **Queues** ⏳
   - A collection of elements that follows the First In First Out (FIFO) principle, where the first added element is the first to be removed.

5. **Hash Tables** 🔑
   - A data structure that uses a hash function to map keys to values, allowing for fast data retrieval.

6. **Trees** 🌳
   - A hierarchical structure consisting of nodes, with a root node and child nodes.
   - **Binary Trees** 🌲: Each node has at most two children (left and right).
   - **Binary Search Trees** 🔍: A binary tree where the left child is less than the parent, and the right child is greater.
   - **AVL Trees** 🌲🔄: A self-balancing binary search tree that maintains height balance.
   - **Segment Trees** 📏: A tree used for storing intervals or segments, enabling efficient range queries.

7. **Graphs** 🕸️
   - A collection of nodes (vertices) connected by edges, representing relationships between entities.
   - **Adjacency List** 📋: A list where each vertex has a list of its adjacent vertices.
   - **Adjacency Matrix** 🗂️: A 2D array representing edges between vertices, where rows and columns represent vertices.

8. **Heaps** ⛰️
   - A complete binary tree used to implement priority queues, where the parent node is either greater (max heap) or less (min heap) than its children.
   - **Min Heap** 🔽: The smallest element is at the root.
   - **Max Heap** 🔼: The largest element is at the root.

### Common Algorithms ⚙️

1. **Sorting Algorithms** 🔄
   - Techniques for arranging elements in a specific order (ascending or descending).
   - **Bubble Sort** 🫧: Repeatedly steps through the list, swapping adjacent elements if they are in the wrong order.
   - **Merge Sort** ➕: Divides the list into halves, sorts them, and merges them back together.
   - **Quick Sort** ⚡: Selects a pivot and partitions the array into elements less than and greater than the pivot.
   - **Heap Sort** 🏔️: Uses a heap data structure to sort elements.

2. **Searching Algorithms** 🔍
   - Methods for finding specific elements within a data structure.
   - **Linear Search** 📏: Checks each element one by one until the target is found.
   - **Binary Search** 📊🔍: Efficiently searches a sorted array by repeatedly dividing the search interval in half.

3. **Graph Algorithms** 🌐
   - Techniques for traversing and analyzing graphs.
   - **Depth-First Search (DFS)** 🌊: Explores as far down a branch as possible before backtracking.
   - **Breadth-First Search (BFS)** 🌬️: Explores all neighbors at the present depth before moving on to nodes at the next depth level.
   - **Dijkstra's Algorithm** 🛤️: Finds the shortest path from a source node to all other nodes in a weighted graph.
   - **Kruskal's Algorithm** ⚖️: Finds the minimum spanning tree for a connected weighted graph.

4. **Dynamic Programming** 📈
   - A method for solving complex problems by breaking them down into simpler subproblems and storing the results to avoid redundant computations.

5. **Backtracking Algorithms** ⏪
   - A recursive approach to solving problems by trying out different possibilities and abandoning paths that do not lead to a solution.

6. **Greedy Algorithms** 🍀
   - A method that builds up a solution piece by piece, always choosing the next piece that offers the most immediate benefit.


