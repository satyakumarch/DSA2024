

### Common Data Structures ğŸ—ï¸

1. **Arrays** ğŸ“Š
   - A collection of elements identified by index or key, allowing for fast access and manipulation.

2. **Linked Lists** ğŸ”—
   - A sequence of elements where each element points to the next, enabling efficient insertion and deletion.
   - **Singly Linked List** â¡ï¸: Each node points to the next node, forming a unidirectional chain.
   - **Doubly Linked List** â†”ï¸: Each node points to both the next and previous nodes, allowing traversal in both directions.

3. **Stacks** ğŸ“š
   - A collection of elements that follows the Last In First Out (LIFO) principle, where the last added element is the first to be removed.

4. **Queues** â³
   - A collection of elements that follows the First In First Out (FIFO) principle, where the first added element is the first to be removed.

5. **Hash Tables** ğŸ”‘
   - A data structure that uses a hash function to map keys to values, allowing for fast data retrieval.

6. **Trees** ğŸŒ³
   - A hierarchical structure consisting of nodes, with a root node and child nodes.
   - **Binary Trees** ğŸŒ²: Each node has at most two children (left and right).
   - **Binary Search Trees** ğŸ”: A binary tree where the left child is less than the parent, and the right child is greater.
   - **AVL Trees** ğŸŒ²ğŸ”„: A self-balancing binary search tree that maintains height balance.
   - **Segment Trees** ğŸ“: A tree used for storing intervals or segments, enabling efficient range queries.

7. **Graphs** ğŸ•¸ï¸
   - A collection of nodes (vertices) connected by edges, representing relationships between entities.
   - **Adjacency List** ğŸ“‹: A list where each vertex has a list of its adjacent vertices.
   - **Adjacency Matrix** ğŸ—‚ï¸: A 2D array representing edges between vertices, where rows and columns represent vertices.

8. **Heaps** â›°ï¸
   - A complete binary tree used to implement priority queues, where the parent node is either greater (max heap) or less (min heap) than its children.
   - **Min Heap** ğŸ”½: The smallest element is at the root.
   - **Max Heap** ğŸ”¼: The largest element is at the root.

### Common Algorithms âš™ï¸

1. **Sorting Algorithms** ğŸ”„
   - Techniques for arranging elements in a specific order (ascending or descending).
   - **Bubble Sort** ğŸ«§: Repeatedly steps through the list, swapping adjacent elements if they are in the wrong order.
   - **Merge Sort** â•: Divides the list into halves, sorts them, and merges them back together.
   - **Quick Sort** âš¡: Selects a pivot and partitions the array into elements less than and greater than the pivot.
   - **Heap Sort** ğŸ”ï¸: Uses a heap data structure to sort elements.

2. **Searching Algorithms** ğŸ”
   - Methods for finding specific elements within a data structure.
   - **Linear Search** ğŸ“: Checks each element one by one until the target is found.
   - **Binary Search** ğŸ“ŠğŸ”: Efficiently searches a sorted array by repeatedly dividing the search interval in half.

3. **Graph Algorithms** ğŸŒ
   - Techniques for traversing and analyzing graphs.
   - **Depth-First Search (DFS)** ğŸŒŠ: Explores as far down a branch as possible before backtracking.
   - **Breadth-First Search (BFS)** ğŸŒ¬ï¸: Explores all neighbors at the present depth before moving on to nodes at the next depth level.
   - **Dijkstra's Algorithm** ğŸ›¤ï¸: Finds the shortest path from a source node to all other nodes in a weighted graph.
   - **Kruskal's Algorithm** âš–ï¸: Finds the minimum spanning tree for a connected weighted graph.

4. **Dynamic Programming** ğŸ“ˆ
   - A method for solving complex problems by breaking them down into simpler subproblems and storing the results to avoid redundant computations.

5. **Backtracking Algorithms** âª
   - A recursive approach to solving problems by trying out different possibilities and abandoning paths that do not lead to a solution.

6. **Greedy Algorithms** ğŸ€
   - A method that builds up a solution piece by piece, always choosing the next piece that offers the most immediate benefit.


